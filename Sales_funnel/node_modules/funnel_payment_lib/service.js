/**
 * Created by daulet on 7/29/16.
 */
var https = require('https');
var qs = require('qs');
var base64 = require('base-64');
var utf8 = require('utf8');
var execPhp = require('exec-php');
var Q = require('q');
var nodeCrypto = require('./NODE_Crypto/helper');

function Service(options){
    this.sysOptions = {
        security: options.security,
        shop: options.shop
    };
    this.order = null;
}

Service.prototype.takeOrder = function (order) {
    if(!order || typeof order !== 'object')
        return false;
    if(!order.hasOwnProperty("id") || !order.hasOwnProperty("currency")
        || !order.hasOwnProperty("amount") || !order.hasOwnProperty("email"))
        return false;

    this.order = order;
    return true;
};

Service.prototype.onPrepareDoc = function (defer, err, doc) {
    if(err)
        defer.reject(err);
    else
        defer.resolve(doc);
};

Service.prototype.onExecParse = function (defer, doc, err, php) {
    if(err)
        defer.reject(err);
    else
        php.parse_xml(doc, this.onPrepareDoc.bind(null, defer));
};

Service.prototype.onGetBankNode = function (defer, doc, err, php) {
    if(err)
        defer.reject(err);
    else
        php.get_bank_node(doc, this.onPrepareDoc.bind(null, defer));
};

Service.prototype.onGetBankSignNode = function (defer, doc, err, php) {
    if(err)
        defer.reject(err);
    else
        php.get_bank_sign_node(doc, this.onPrepareDoc.bind(null, defer));
};

Service.prototype.onExecPrepareOrder = function(defer, error, php, outprint){
    if(error)
        defer.reject(error);
    else
        php.preparedocument(this.sysOptions.security, this.sysOptions.shop, this.order,
            this.onPrepareDoc.bind(null, defer));
};

Service.prototype.createPaymentDocument = function () {
    var defer = Q.defer();

    if(!this.order || this.order === '{}'){
        defer.reject(new Error("PaymentService: Order is empty. Refusal to create a document!"));
    }

    execPhp('./PHP_KKBSign/doccreator.php', this.onExecPrepareOrder.bind(this, defer));
    return defer.promise;
};

Service.prototype.signVerify = function (bankXMLDocument) {
    var deferred = Q.defer();
    var bankXML = bankXMLDocument[0];
    var sign = bankXMLDocument[1]["0"];
    var verifyResult;

    if(!sign || !bankXML){
        deferred.reject(new Error("Bank Sign or Bank Reply Is NULL!"));
    }
    else {
        verifyResult = this.doVerifyBankReply(sign, bankXML);
        console.log("Sign Verify Args:", JSON.stringify(bankXML), "Bank Sign Is", sign);

        if (verifyResult instanceof Error) {
            deferred.reject(new Error(verifyResult.message))
        }
        else if(!verifyResult){
            deferred.reject(new Error("Signature verification failed bank! Signature or Key Bank untrue"))
        }
        else {
            deferred.resolve(verifyResult);
        }
    }
    return deferred.promise;
};

Service.prototype.doVerifyBankReply = function (sign, bankdocument) {
    var isVerify = false;
    try {
        if(!sign){
            throw new Error("The Bank Sign is empty or not found!");
        }
        isVerify = nodeCrypto.Base64._verifySign(this.sysOptions.security.pubkey, sign, bankdocument);
    } catch (e) {
        isVerify = e;
    }
    return isVerify;
};

Service.prototype.createBase64 = function (xmlDoc) {
    var encodedXMLDoc = utf8.encode(xmlDoc);
    var $xmlbase64 = base64.encode(encodedXMLDoc);

    return $xmlbase64;
};

Service.prototype.parseXMLDocument = function (xmlDocStr) {
    var defer = Q.defer();
    execPhp('./PHP_KKBSign/doccreator.php', this.onExecParse.bind(this, defer, xmlDocStr));
    return defer.promise;
};

Service.prototype.getBankChildElement = function (xmlDocStr) {
    var defer = Q.defer();
    execPhp('./PHP_KKBSign/doccreator.php', this.onGetBankNode.bind(this, defer, xmlDocStr));
    return defer.promise;
};

Service.prototype.getBankSignChildElement = function (xmlDocStr) {
    var defer = Q.defer();
    execPhp('./PHP_KKBSign/doccreator.php', this.onGetBankSignNode.bind(this, defer, xmlDocStr));
    return defer.promise;
};

Service.prototype.getReadyOrder = function (structAsJSON) {
    var deferred = Q.defer();
    if(!structAsJSON || typeof structAsJSON !== 'object'){
        deferred.reject(new Error("An error occurred while parsing document XML!" +
            "The document is empty or is not an object"))
    }
    else if(!structAsJSON.hasOwnProperty("customer")){
        deferred.reject(new Error("An error occurred while parsing document XML!" +
            "The document has not <customer> element"))
    }
    else if(!structAsJSON.customer.hasOwnProperty("merchant")){
        deferred.reject(new Error("An error occurred while parsing document XML!" +
            "The customer has not <merchant> element"))
    }
    else if(!structAsJSON.customer.merchant.hasOwnProperty("order")){
        deferred.reject(new Error("An error occurred while parsing document XML!" +
            "The merchant has not <order> element"))
    }else{
        deferred.resolve(structAsJSON.customer.merchant.order);
    }

    return deferred.promise;
};

Service.prototype.onStreamError = function (defer, e) {
    console.error("INFO: PaymentService: PaymentStream Error " + e);
    defer.reject(e);
};

module.exports = Service;
